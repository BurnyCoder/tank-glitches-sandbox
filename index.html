<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flying Tank Glitch - Three.js</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #1a1a2e; }
        canvas { display: block; }
        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
        }
        #ui h2 { color: #4ecdc4; margin-bottom: 10px; }
        #ui p { margin: 5px 0; color: #ccc; }
        #ui .controls { color: #f39c12; }
        #ui .tip { color: #e74c3c; font-weight: bold; margin-top: 10px; }
        #status {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            text-align: right;
        }
        #status .flying { color: #e74c3c; font-size: 24px; animation: pulse 0.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    </style>
</head>
<body>
    <div id="ui">
        <h2>FLYING TANK GLITCH</h2>
        <p class="controls">WASD - Move tank</p>
        <p class="controls">SPACE - Jump (hold for bhop!)</p>
        <p class="controls">R - Reset position</p>
        <p class="tip">Drive into the RED ZONES to trigger the flying glitch!</p>
    </div>
    <div id="status">
        <div>Height: <span id="height">0.0</span>m</div>
        <div>Speed: <span id="speed">0.0</span> km/h</div>
        <div>Bhop Chain: <span id="bhopChain">0</span></div>
        <div id="flyingStatus"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Game State
        const state = {
            keys: {},
            tank: null,
            velocity: new THREE.Vector3(),
            angularVelocity: 0,
            onGround: true,
            isShaking: false,
            shakeIntensity: 0,
            launchPending: false,
            launchTimer: 0,
            glitchZones: [],
            // Bunnyhopping state
            bhopSpeed: 0,           // Accumulated bhop speed bonus
            bhopChain: 0,           // Consecutive bhop count
            wasOnGround: true,      // For detecting landing frame
            jumpQueued: false       // For held spacebar auto-jump
        };

        // Constants - Based on WoT glitch behavior
        const TANK_SPEED = 15;
        const TANK_TURN_SPEED = 2;
        const GRAVITY = -25;
        const GROUND_FRICTION = 0.95;
        const AIR_FRICTION = 1.0;            // No speed loss in air
        const GLITCH_LAUNCH_FORCE = 50; // How high the tank flies
        const SHAKE_DURATION = 1.5; // Seconds of shaking before launch

        // Bunnyhopping constants
        const BHOP_JUMP_FORCE = 12;         // Base jump velocity
        const BHOP_SPEED_BOOST = 3;         // Speed added per successful bhop
        const BHOP_MAX_SPEED = 60;          // Maximum bhop speed cap
        const BHOP_DECAY = 0.97;            // Speed decay when not bhopping

        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 50, 200);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x6688cc, 0.4);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffee, 1.2);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 10;
        sunLight.shadow.camera.far = 300;
        sunLight.shadow.camera.left = -100;
        sunLight.shadow.camera.right = 100;
        sunLight.shadow.camera.top = 100;
        sunLight.shadow.camera.bottom = -100;
        scene.add(sunLight);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x3d5c3d,
            roughness: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Grid helper for reference
        const gridHelper = new THREE.GridHelper(200, 50, 0x444444, 0x333333);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);

        // Create Tank (simplified box tank)
        function createTank() {
            const tankGroup = new THREE.Group();

            // Tank body
            const bodyGeometry = new THREE.BoxGeometry(3, 1, 5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x556b2f, roughness: 0.6 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.8;
            body.castShadow = true;
            tankGroup.add(body);

            // Tank turret
            const turretGeometry = new THREE.BoxGeometry(2, 0.8, 2.5);
            const turret = new THREE.Mesh(turretGeometry, bodyMaterial);
            turret.position.y = 1.7;
            turret.position.z = -0.3;
            turret.castShadow = true;
            tankGroup.add(turret);

            // Tank barrel
            const barrelGeometry = new THREE.CylinderGeometry(0.15, 0.15, 3);
            const barrel = new THREE.Mesh(barrelGeometry, bodyMaterial);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 1.7, -2.5);
            barrel.castShadow = true;
            tankGroup.add(barrel);

            // Tracks (left and right)
            const trackGeometry = new THREE.BoxGeometry(0.6, 0.6, 5.2);
            const trackMaterial = new THREE.MeshStandardMaterial({ color: 0x2d2d2d, roughness: 0.9 });

            const leftTrack = new THREE.Mesh(trackGeometry, trackMaterial);
            leftTrack.position.set(-1.5, 0.3, 0);
            leftTrack.castShadow = true;
            tankGroup.add(leftTrack);

            const rightTrack = new THREE.Mesh(trackGeometry, trackMaterial);
            rightTrack.position.set(1.5, 0.3, 0);
            rightTrack.castShadow = true;
            tankGroup.add(rightTrack);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });

            for (let side = -1; side <= 1; side += 2) {
                for (let i = -2; i <= 2; i++) {
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(side * 1.8, 0.3, i * 1.1);
                    tankGroup.add(wheel);
                }
            }

            tankGroup.position.set(0, 0.1, 30);
            return tankGroup;
        }

        // Create Glitch Zone (trigger areas that cause the flying glitch)
        function createGlitchZone(x, z, width, depth, height = 3) {
            const group = new THREE.Group();

            // Visible structure (like the watermill in WoT Pearl River)
            const structureGeometry = new THREE.BoxGeometry(width, height, depth);
            const structureMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b4513,
                roughness: 0.9
            });
            const structure = new THREE.Mesh(structureGeometry, structureMaterial);
            structure.position.y = height / 2;
            structure.castShadow = true;
            structure.receiveShadow = true;
            group.add(structure);

            // Red warning zone (invisible trigger area slightly larger)
            const zoneGeometry = new THREE.BoxGeometry(width + 2, 0.1, depth + 2);
            const zoneMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.3
            });
            const zone = new THREE.Mesh(zoneGeometry, zoneMaterial);
            zone.position.y = 0.05;
            group.add(zone);

            // Pulsing effect for the zone
            zone.userData.pulse = 0;

            group.position.set(x, 0, z);

            // Store zone bounds for collision detection
            state.glitchZones.push({
                mesh: group,
                zone: zone,
                bounds: {
                    minX: x - (width + 2) / 2,
                    maxX: x + (width + 2) / 2,
                    minZ: z - (depth + 2) / 2,
                    maxZ: z + (depth + 2) / 2
                }
            });

            return group;
        }

        // Create environment
        function createEnvironment() {
            // Add several glitch zones around the map
            scene.add(createGlitchZone(0, 0, 4, 4, 2)); // Center structure
            scene.add(createGlitchZone(-20, -15, 6, 3, 4)); // Left structure
            scene.add(createGlitchZone(25, 10, 3, 6, 3)); // Right structure
            scene.add(createGlitchZone(15, -25, 5, 5, 5)); // Far structure
            scene.add(createGlitchZone(-30, 20, 4, 8, 3)); // Another structure

            // Add some decorative rocks
            const rockGeometry = new THREE.DodecahedronGeometry(1.5);
            const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });

            const rockPositions = [
                [-10, 5], [12, -8], [-25, -5], [30, -20], [-15, 25]
            ];

            rockPositions.forEach(([x, z]) => {
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(x, 0.8, z);
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                rock.scale.set(0.5 + Math.random(), 0.5 + Math.random(), 0.5 + Math.random());
                rock.castShadow = true;
                scene.add(rock);
            });

            // Add trees (simple cones)
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x4a3520 });
            const foliageGeometry = new THREE.ConeGeometry(2, 4, 8);
            const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22 });

            const treePositions = [
                [-40, 0], [-35, 15], [-45, -20], [40, 5], [45, -15], [35, 25],
                [-20, 40], [20, -40], [-40, -35], [40, 35]
            ];

            treePositions.forEach(([x, z]) => {
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(x, 1, z);
                trunk.castShadow = true;
                scene.add(trunk);

                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.set(x, 4, z);
                foliage.castShadow = true;
                scene.add(foliage);
            });
        }

        // Initialize
        state.tank = createTank();
        scene.add(state.tank);
        createEnvironment();

        // Camera follow setup
        const cameraOffset = new THREE.Vector3(0, 8, 15);
        camera.position.copy(state.tank.position).add(cameraOffset);

        // Controls
        window.addEventListener('keydown', (e) => {
            state.keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (e) => {
            state.keys[e.key.toLowerCase()] = false;
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // UI Elements
        const heightDisplay = document.getElementById('height');
        const speedDisplay = document.getElementById('speed');
        const flyingStatusDisplay = document.getElementById('flyingStatus');
        const bhopChainDisplay = document.getElementById('bhopChain');

        // Check if tank is in a glitch zone
        function checkGlitchZones() {
            const tankPos = state.tank.position;

            for (const zone of state.glitchZones) {
                const b = zone.bounds;
                if (tankPos.x >= b.minX && tankPos.x <= b.maxX &&
                    tankPos.z >= b.minZ && tankPos.z <= b.maxZ &&
                    state.onGround) {
                    return zone;
                }
            }
            return null;
        }

        // Apply shaking effect (like WoT before launch)
        function applyShaking(deltaTime) {
            if (state.isShaking) {
                state.shakeIntensity = Math.min(state.shakeIntensity + deltaTime * 2, 1);

                // Random shake offset
                const shakeAmount = state.shakeIntensity * 0.15;
                state.tank.position.x += (Math.random() - 0.5) * shakeAmount;
                state.tank.position.z += (Math.random() - 0.5) * shakeAmount;
                state.tank.rotation.z = (Math.random() - 0.5) * shakeAmount * 0.5;
                state.tank.rotation.x = (Math.random() - 0.5) * shakeAmount * 0.3;
            } else {
                // Reset rotation when not shaking
                state.tank.rotation.x *= 0.9;
                state.tank.rotation.z *= 0.9;
                state.shakeIntensity = 0;
            }
        }

        // Launch the tank into the air (the glitch effect!)
        function launchTank() {
            // Random launch direction with strong upward component
            const launchAngle = Math.random() * Math.PI * 2;
            const horizontalForce = 5 + Math.random() * 10;

            state.velocity.x = Math.cos(launchAngle) * horizontalForce;
            state.velocity.y = GLITCH_LAUNCH_FORCE + Math.random() * 20;
            state.velocity.z = Math.sin(launchAngle) * horizontalForce;

            // Add spin
            state.angularVelocity = (Math.random() - 0.5) * 5;

            state.onGround = false;
            state.isShaking = false;
            state.launchPending = false;
            state.launchTimer = 0;
        }

        // Reset tank position
        function resetTank() {
            state.tank.position.set(0, 0.1, 30);
            state.tank.rotation.set(0, 0, 0);
            state.velocity.set(0, 0, 0);
            state.angularVelocity = 0;
            state.onGround = true;
            state.isShaking = false;
            state.launchPending = false;
            state.launchTimer = 0;
            // Reset bhop state
            state.bhopSpeed = 0;
            state.bhopChain = 0;
            state.jumpQueued = false;
        }

        // Game loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(clock.getDelta(), 0.1);

            // Tank controls (only when on ground and not shaking violently)
            if (state.onGround && !state.launchPending) {
                const moveDir = new THREE.Vector3();

                if (state.keys['w']) moveDir.z = -1;
                if (state.keys['s']) moveDir.z = 1;
                if (state.keys['a']) state.tank.rotation.y += TANK_TURN_SPEED * deltaTime;
                if (state.keys['d']) state.tank.rotation.y -= TANK_TURN_SPEED * deltaTime;

                // Calculate base movement speed + bhop bonus
                const totalSpeed = TANK_SPEED + state.bhopSpeed;

                if (moveDir.length() > 0) {
                    moveDir.applyQuaternion(state.tank.quaternion);
                    moveDir.normalize().multiplyScalar(totalSpeed);
                    state.velocity.x = moveDir.x;
                    state.velocity.z = moveDir.z;
                }

                // Bunnyhopping - Jump when spacebar is pressed/held
                if (state.keys[' ']) {
                    state.jumpQueued = true;
                }
            }

            // Process queued jump (works for both tap and hold)
            if (state.jumpQueued && state.onGround && !state.launchPending) {
                // Execute bhop jump
                state.velocity.y = BHOP_JUMP_FORCE;
                state.onGround = false;
                state.jumpQueued = false;

                // Check if this is a successful bhop (had horizontal momentum)
                const horizontalSpeed = Math.sqrt(state.velocity.x ** 2 + state.velocity.z ** 2);
                if (horizontalSpeed > 5) {
                    // Successful bhop - add speed boost!
                    state.bhopChain++;
                    state.bhopSpeed = Math.min(state.bhopSpeed + BHOP_SPEED_BOOST, BHOP_MAX_SPEED - TANK_SPEED);

                    // Add a little forward boost in movement direction
                    const boostDir = new THREE.Vector3(state.velocity.x, 0, state.velocity.z).normalize();
                    state.velocity.x += boostDir.x * BHOP_SPEED_BOOST;
                    state.velocity.z += boostDir.z * BHOP_SPEED_BOOST;
                } else {
                    // Standing jump - reset chain
                    state.bhopChain = 0;
                }
            }

            // Queue jump if spacebar held while in air (for auto-bhop on landing)
            if (state.keys[' '] && !state.onGround) {
                state.jumpQueued = true;
            }

            // Check for glitch zones
            const currentZone = checkGlitchZones();
            if (currentZone && !state.launchPending) {
                state.isShaking = true;
                state.launchPending = true;
                state.launchTimer = 0;
            }

            // Handle launch timing
            if (state.launchPending) {
                state.launchTimer += deltaTime;
                if (state.launchTimer >= SHAKE_DURATION) {
                    launchTank();
                }
            }

            // Apply gravity when airborne
            if (!state.onGround) {
                state.velocity.y += GRAVITY * deltaTime;

                // Air rotation
                state.tank.rotation.x += state.angularVelocity * 0.3 * deltaTime;
                state.tank.rotation.z += state.angularVelocity * deltaTime;
            }

            // Apply velocity
            state.tank.position.add(state.velocity.clone().multiplyScalar(deltaTime));

            // Ground collision
            if (state.tank.position.y <= 0.1) {
                state.tank.position.y = 0.1;
                if (!state.onGround) {
                    // Landing impact
                    state.velocity.y = 0;
                    state.angularVelocity = 0;

                    // BHOP MECHANIC: If jump is queued (holding space), bypass landing friction!
                    if (state.jumpQueued) {
                        // Perfect bhop - preserve momentum (the 1-frame friction bypass)
                        // Only apply minimal friction
                        state.velocity.x *= 0.98;
                        state.velocity.z *= 0.98;
                    } else {
                        // Normal landing - lose speed and reset bhop chain
                        state.velocity.multiplyScalar(0.3);
                        state.bhopSpeed *= 0.5; // Lose half bhop speed on failed landing
                        state.bhopChain = 0;
                    }
                }
                state.onGround = true;
            }

            // Decay bhop speed when on ground and not jumping
            if (state.onGround && !state.keys[' ']) {
                state.bhopSpeed *= BHOP_DECAY;
                if (state.bhopSpeed < 0.5) state.bhopSpeed = 0;
            }

            // Apply friction (reduced during bhop chain)
            let friction = state.onGround ? GROUND_FRICTION : AIR_FRICTION;
            if (state.bhopChain > 0 && state.onGround) {
                friction = 0.99; // Much less friction during active bhop
            }
            state.velocity.x *= friction;
            state.velocity.z *= friction;

            // Apply shaking effect
            applyShaking(deltaTime);

            // Reset key
            if (state.keys['r']) {
                resetTank();
            }

            // Pulse glitch zones
            state.glitchZones.forEach(zone => {
                zone.zone.userData.pulse += deltaTime * 3;
                zone.zone.material.opacity = 0.2 + Math.sin(zone.zone.userData.pulse) * 0.15;
            });

            // Camera follow with smooth lerp
            const targetCameraPos = state.tank.position.clone();
            const cameraDir = new THREE.Vector3(0, 0, 1).applyQuaternion(state.tank.quaternion);
            targetCameraPos.add(cameraDir.multiplyScalar(15));
            targetCameraPos.y = state.tank.position.y + 8;

            camera.position.lerp(targetCameraPos, 0.05);
            camera.lookAt(state.tank.position);

            // Update UI
            heightDisplay.textContent = Math.max(0, state.tank.position.y - 0.1).toFixed(1);
            const speed = Math.sqrt(state.velocity.x ** 2 + state.velocity.z ** 2) * 3.6;
            speedDisplay.textContent = speed.toFixed(1);
            bhopChainDisplay.textContent = state.bhopChain;

            // Color bhop chain based on count
            if (state.bhopChain >= 5) {
                bhopChainDisplay.style.color = '#e74c3c'; // Red for high chain
            } else if (state.bhopChain >= 3) {
                bhopChainDisplay.style.color = '#f39c12'; // Orange for medium
            } else if (state.bhopChain > 0) {
                bhopChainDisplay.style.color = '#4ecdc4'; // Cyan for active
            } else {
                bhopChainDisplay.style.color = '#fff';
            }

            if (!state.onGround) {
                if (state.bhopChain > 0) {
                    flyingStatusDisplay.innerHTML = `<span style="color: #4ecdc4;">BHOPPING! x${state.bhopChain}</span>`;
                } else {
                    flyingStatusDisplay.innerHTML = '<span class="flying">FLYING!</span>';
                }
            } else if (state.isShaking) {
                flyingStatusDisplay.innerHTML = '<span style="color: #f39c12;">GLITCH DETECTED!</span>';
            } else if (state.bhopChain > 0) {
                flyingStatusDisplay.innerHTML = `<span style="color: #4ecdc4;">BHOP CHAIN: ${state.bhopChain}</span>`;
            } else {
                flyingStatusDisplay.innerHTML = '';
            }

            // Keep tank in bounds
            state.tank.position.x = Math.max(-95, Math.min(95, state.tank.position.x));
            state.tank.position.z = Math.max(-95, Math.min(95, state.tank.position.z));

            renderer.render(scene, camera);
        }

        animate();

        console.log('Flying Tank Glitch loaded!');
        console.log('Drive into the RED zones to experience the flying glitch!');
        console.log('BHOP: Hold SPACE while moving to bunnyhop and gain speed!');
    </script>
</body>
</html>
