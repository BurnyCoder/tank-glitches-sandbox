<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flying Tank Glitch - Three.js</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #1a1a2e; }
        canvas { display: block; }
        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
        }
        #ui h2 { color: #4ecdc4; margin-bottom: 10px; }
        #ui p { margin: 5px 0; color: #ccc; }
        #ui .controls { color: #f39c12; }
        #ui .tip { color: #e74c3c; font-weight: bold; margin-top: 10px; }
        #status {
            position: fixed;
            top: 20px;
            right: 20px;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            text-align: right;
        }
        #status .flying { color: #e74c3c; font-size: 24px; animation: pulse 0.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    </style>
</head>
<body>
    <div id="ui">
        <h2>FLYING TANK GLITCH</h2>
        <p class="controls">WASD - Move tank</p>
        <p class="controls">SPACE - Jump (hold for bhop!)</p>
        <p class="controls">R - Reset position</p>
        <p class="tip">Drive into the RED ZONES to trigger the flying glitch!</p>
    </div>
    <div id="status">
        <div>Height: <span id="height">0.0</span>m</div>
        <div>Speed: <span id="speed">0.0</span> km/h</div>
        <div>Bhop Chain: <span id="bhopChain">0</span></div>
        <div id="flyingStatus"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Game State
        const state = {
            keys: {},
            tank: null,
            velocity: new THREE.Vector3(),
            angularVelocity: 0,
            onGround: true,
            isShaking: false,
            shakeIntensity: 0,
            launchPending: false,
            launchTimer: 0,
            glitchZones: [],
            // Bunnyhopping state
            bhopSpeed: 0,           // Accumulated bhop speed bonus
            bhopChain: 0,           // Consecutive bhop count
            wasOnGround: true,      // For detecting landing frame
            jumpQueued: false       // For held spacebar auto-jump
        };

        // Constants - Based on WoT glitch behavior
        const TANK_SPEED = 15;
        const TANK_TURN_SPEED = 2;
        const GRAVITY = -25;
        const GROUND_FRICTION = 1.0;         // No friction - infinite speed!
        const AIR_FRICTION = 1.0;            // No speed loss in air
        const GLITCH_LAUNCH_FORCE = 50; // How high the tank flies
        const SHAKE_DURATION = 1.5; // Seconds of shaking before launch

        // Bunnyhopping constants
        const BHOP_JUMP_FORCE = 12;         // Base jump velocity
        const BHOP_SPEED_BOOST = 5;         // Base speed added per bhop
        const BHOP_MULTIPLIER = 1.15;       // Exponential multiplier per bhop
        const AIR_CONTROL = 0.5;            // Air strafe/turn multiplier (0-1)

        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 100, 500); // Extended for high speed visibility

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x6688cc, 0.4);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffee, 1.2);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 10;
        sunLight.shadow.camera.far = 300;
        sunLight.shadow.camera.left = -100;
        sunLight.shadow.camera.right = 100;
        sunLight.shadow.camera.top = 100;
        sunLight.shadow.camera.bottom = -100;
        scene.add(sunLight);
        scene.add(sunLight.target); // For following player

        // Ground (large, follows player)
        const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x3d5c3d,
            roughness: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Grid helper for reference (follows player)
        const gridHelper = new THREE.GridHelper(1000, 250, 0x444444, 0x333333);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);

        // Procedural generation system
        const CHUNK_SIZE = 50;
        const RENDER_DISTANCE = 3; // chunks
        const generatedChunks = new Set();
        const chunkObjects = new Map(); // chunk key -> array of objects

        // Seeded random for consistent procedural generation
        function seededRandom(seed) {
            const x = Math.sin(seed * 12.9898 + seed * 78.233) * 43758.5453;
            return x - Math.floor(x);
        }

        function getChunkKey(cx, cz) {
            return `${cx},${cz}`;
        }

        // Shared geometries and materials for procedural objects
        const procRockGeometry = new THREE.DodecahedronGeometry(1.5);
        const procRockMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });
        const procTrunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2);
        const procTrunkMaterial = new THREE.MeshStandardMaterial({ color: 0x4a3520 });
        const procFoliageGeometry = new THREE.ConeGeometry(2, 4, 8);
        const procFoliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22 });

        function generateChunk(cx, cz) {
            const key = getChunkKey(cx, cz);
            if (generatedChunks.has(key)) return;
            generatedChunks.add(key);

            const objects = [];
            const baseX = cx * CHUNK_SIZE;
            const baseZ = cz * CHUNK_SIZE;
            const seed = cx * 10000 + cz;

            // Generate trees (2-4 per chunk)
            const numTrees = 2 + Math.floor(seededRandom(seed) * 3);
            for (let i = 0; i < numTrees; i++) {
                const tx = baseX + seededRandom(seed + i * 100) * CHUNK_SIZE;
                const tz = baseZ + seededRandom(seed + i * 100 + 50) * CHUNK_SIZE;

                const trunk = new THREE.Mesh(procTrunkGeometry, procTrunkMaterial);
                trunk.position.set(tx, 1, tz);
                trunk.castShadow = true;
                scene.add(trunk);
                objects.push(trunk);

                const foliage = new THREE.Mesh(procFoliageGeometry, procFoliageMaterial);
                foliage.position.set(tx, 4, tz);
                foliage.castShadow = true;
                scene.add(foliage);
                objects.push(foliage);
            }

            // Generate rocks (1-3 per chunk)
            const numRocks = 1 + Math.floor(seededRandom(seed + 500) * 3);
            for (let i = 0; i < numRocks; i++) {
                const rx = baseX + seededRandom(seed + i * 200 + 1000) * CHUNK_SIZE;
                const rz = baseZ + seededRandom(seed + i * 200 + 1050) * CHUNK_SIZE;

                const rock = new THREE.Mesh(procRockGeometry, procRockMaterial);
                rock.position.set(rx, 0.8, rz);
                const rs = seededRandom(seed + i * 200 + 1100);
                rock.rotation.set(rs * 6, rs * 4, rs * 5);
                rock.scale.set(0.5 + rs * 0.5, 0.5 + rs * 0.5, 0.5 + rs * 0.5);
                rock.castShadow = true;
                scene.add(rock);
                objects.push(rock);
            }

            // Generate glitch zone (15% chance per chunk, not in center chunks)
            if (seededRandom(seed + 2000) < 0.15 && (Math.abs(cx) > 1 || Math.abs(cz) > 1)) {
                const gx = baseX + CHUNK_SIZE / 2 + (seededRandom(seed + 2100) - 0.5) * 20;
                const gz = baseZ + CHUNK_SIZE / 2 + (seededRandom(seed + 2200) - 0.5) * 20;
                const gw = 3 + seededRandom(seed + 2300) * 4;
                const gd = 3 + seededRandom(seed + 2400) * 4;
                const gh = 2 + seededRandom(seed + 2500) * 4;

                const glitchGroup = createGlitchZone(gx, gz, gw, gd, gh);
                scene.add(glitchGroup);
                objects.push(glitchGroup);
            }

            chunkObjects.set(key, objects);
        }

        function removeChunk(cx, cz) {
            const key = getChunkKey(cx, cz);
            if (!chunkObjects.has(key)) return;

            const objects = chunkObjects.get(key);
            objects.forEach(obj => {
                scene.remove(obj);
                // Remove from glitchZones if it's a glitch zone
                const idx = state.glitchZones.findIndex(z => z.mesh === obj);
                if (idx !== -1) state.glitchZones.splice(idx, 1);
            });
            chunkObjects.delete(key);
            generatedChunks.delete(key);
        }

        function updateChunks(playerX, playerZ) {
            const playerCX = Math.floor(playerX / CHUNK_SIZE);
            const playerCZ = Math.floor(playerZ / CHUNK_SIZE);

            // Generate nearby chunks
            for (let dx = -RENDER_DISTANCE; dx <= RENDER_DISTANCE; dx++) {
                for (let dz = -RENDER_DISTANCE; dz <= RENDER_DISTANCE; dz++) {
                    generateChunk(playerCX + dx, playerCZ + dz);
                }
            }

            // Remove far chunks
            for (const key of generatedChunks) {
                const [cx, cz] = key.split(',').map(Number);
                if (Math.abs(cx - playerCX) > RENDER_DISTANCE + 1 ||
                    Math.abs(cz - playerCZ) > RENDER_DISTANCE + 1) {
                    removeChunk(cx, cz);
                }
            }
        }

        // Create Tank (simplified box tank)
        function createTank() {
            const tankGroup = new THREE.Group();

            // Tank body
            const bodyGeometry = new THREE.BoxGeometry(3, 1, 5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x556b2f, roughness: 0.6 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.8;
            body.castShadow = true;
            tankGroup.add(body);

            // Tank turret
            const turretGeometry = new THREE.BoxGeometry(2, 0.8, 2.5);
            const turret = new THREE.Mesh(turretGeometry, bodyMaterial);
            turret.position.y = 1.7;
            turret.position.z = -0.3;
            turret.castShadow = true;
            tankGroup.add(turret);

            // Tank barrel
            const barrelGeometry = new THREE.CylinderGeometry(0.15, 0.15, 3);
            const barrel = new THREE.Mesh(barrelGeometry, bodyMaterial);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 1.7, -2.5);
            barrel.castShadow = true;
            tankGroup.add(barrel);

            // Tracks (left and right)
            const trackGeometry = new THREE.BoxGeometry(0.6, 0.6, 5.2);
            const trackMaterial = new THREE.MeshStandardMaterial({ color: 0x2d2d2d, roughness: 0.9 });

            const leftTrack = new THREE.Mesh(trackGeometry, trackMaterial);
            leftTrack.position.set(-1.5, 0.3, 0);
            leftTrack.castShadow = true;
            tankGroup.add(leftTrack);

            const rightTrack = new THREE.Mesh(trackGeometry, trackMaterial);
            rightTrack.position.set(1.5, 0.3, 0);
            rightTrack.castShadow = true;
            tankGroup.add(rightTrack);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });

            for (let side = -1; side <= 1; side += 2) {
                for (let i = -2; i <= 2; i++) {
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(side * 1.8, 0.3, i * 1.1);
                    tankGroup.add(wheel);
                }
            }

            tankGroup.position.set(0, 0.1, 30);
            return tankGroup;
        }

        // Create Glitch Zone (trigger areas that cause the flying glitch)
        function createGlitchZone(x, z, width, depth, height = 3) {
            const group = new THREE.Group();

            // Visible structure (like the watermill in WoT Pearl River)
            const structureGeometry = new THREE.BoxGeometry(width, height, depth);
            const structureMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b4513,
                roughness: 0.9
            });
            const structure = new THREE.Mesh(structureGeometry, structureMaterial);
            structure.position.y = height / 2;
            structure.castShadow = true;
            structure.receiveShadow = true;
            group.add(structure);

            // Red warning zone (invisible trigger area slightly larger)
            const zoneGeometry = new THREE.BoxGeometry(width + 2, 0.1, depth + 2);
            const zoneMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.3
            });
            const zone = new THREE.Mesh(zoneGeometry, zoneMaterial);
            zone.position.y = 0.05;
            group.add(zone);

            // Pulsing effect for the zone
            zone.userData.pulse = 0;

            group.position.set(x, 0, z);

            // Store zone bounds for collision detection
            state.glitchZones.push({
                mesh: group,
                zone: zone,
                bounds: {
                    minX: x - (width + 2) / 2,
                    maxX: x + (width + 2) / 2,
                    minZ: z - (depth + 2) / 2,
                    maxZ: z + (depth + 2) / 2
                }
            });

            return group;
        }

        // Create environment (just center glitch zone, rest is procedural)
        function createEnvironment() {
            // Add center glitch zone as a landmark
            scene.add(createGlitchZone(0, 0, 4, 4, 2));

            // Generate initial chunks around spawn
            updateChunks(0, 30);
        }

        // Initialize
        state.tank = createTank();
        scene.add(state.tank);
        createEnvironment();

        // Camera follow setup
        const cameraOffset = new THREE.Vector3(0, 8, 15);
        camera.position.copy(state.tank.position).add(cameraOffset);

        // Controls
        window.addEventListener('keydown', (e) => {
            state.keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (e) => {
            state.keys[e.key.toLowerCase()] = false;
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // UI Elements
        const heightDisplay = document.getElementById('height');
        const speedDisplay = document.getElementById('speed');
        const flyingStatusDisplay = document.getElementById('flyingStatus');
        const bhopChainDisplay = document.getElementById('bhopChain');

        // Check if tank is in a glitch zone
        function checkGlitchZones() {
            const tankPos = state.tank.position;

            for (const zone of state.glitchZones) {
                const b = zone.bounds;
                if (tankPos.x >= b.minX && tankPos.x <= b.maxX &&
                    tankPos.z >= b.minZ && tankPos.z <= b.maxZ &&
                    state.onGround) {
                    return zone;
                }
            }
            return null;
        }

        // Apply shaking effect (like WoT before launch)
        function applyShaking(deltaTime) {
            if (state.isShaking) {
                state.shakeIntensity = Math.min(state.shakeIntensity + deltaTime * 2, 1);

                // Random shake offset
                const shakeAmount = state.shakeIntensity * 0.15;
                state.tank.position.x += (Math.random() - 0.5) * shakeAmount;
                state.tank.position.z += (Math.random() - 0.5) * shakeAmount;
                state.tank.rotation.z = (Math.random() - 0.5) * shakeAmount * 0.5;
                state.tank.rotation.x = (Math.random() - 0.5) * shakeAmount * 0.3;
            } else {
                // Reset rotation when not shaking
                state.tank.rotation.x *= 0.9;
                state.tank.rotation.z *= 0.9;
                state.shakeIntensity = 0;
            }
        }

        // Launch the tank into the air (the glitch effect!)
        function launchTank() {
            // Random launch direction with strong upward component
            const launchAngle = Math.random() * Math.PI * 2;
            const horizontalForce = 5 + Math.random() * 10;

            state.velocity.x = Math.cos(launchAngle) * horizontalForce;
            state.velocity.y = GLITCH_LAUNCH_FORCE + Math.random() * 20;
            state.velocity.z = Math.sin(launchAngle) * horizontalForce;

            // Add spin
            state.angularVelocity = (Math.random() - 0.5) * 5;

            state.onGround = false;
            state.isShaking = false;
            state.launchPending = false;
            state.launchTimer = 0;
        }

        // Reset tank position
        function resetTank() {
            state.tank.position.set(0, 0.1, 30);
            state.tank.rotation.set(0, 0, 0);
            state.velocity.set(0, 0, 0);
            state.angularVelocity = 0;
            state.onGround = true;
            state.isShaking = false;
            state.launchPending = false;
            state.launchTimer = 0;
            // Reset bhop state
            state.bhopSpeed = 0;
            state.bhopChain = 0;
            state.jumpQueued = false;
        }

        // Game loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(clock.getDelta(), 0.1);

            // Tank controls (only when on ground and not shaking violently)
            if (state.onGround && !state.launchPending) {
                const moveDir = new THREE.Vector3();

                if (state.keys['w']) moveDir.z = -1;
                if (state.keys['s']) moveDir.z = 1;
                if (state.keys['a']) state.tank.rotation.y += TANK_TURN_SPEED * deltaTime;
                if (state.keys['d']) state.tank.rotation.y -= TANK_TURN_SPEED * deltaTime;

                // Calculate base movement speed + bhop bonus
                const totalSpeed = TANK_SPEED + state.bhopSpeed;

                if (moveDir.length() > 0) {
                    moveDir.applyQuaternion(state.tank.quaternion);
                    moveDir.normalize().multiplyScalar(totalSpeed);
                    state.velocity.x = moveDir.x;
                    state.velocity.z = moveDir.z;
                }

                // Bunnyhopping - Jump when spacebar is pressed/held
                if (state.keys[' ']) {
                    state.jumpQueued = true;
                }
            }

            // Air control - allow turning and strafing while airborne
            if (!state.onGround && !state.launchPending) {
                // Air turning
                if (state.keys['a']) state.tank.rotation.y += TANK_TURN_SPEED * AIR_CONTROL * deltaTime;
                if (state.keys['d']) state.tank.rotation.y -= TANK_TURN_SPEED * AIR_CONTROL * deltaTime;

                // Air strafing - add velocity in movement direction
                const airMoveDir = new THREE.Vector3();
                if (state.keys['w']) airMoveDir.z = -1;
                if (state.keys['s']) airMoveDir.z = 1;

                if (airMoveDir.length() > 0) {
                    airMoveDir.applyQuaternion(state.tank.quaternion);
                    airMoveDir.normalize();
                    // Add air strafe influence (doesn't override, just nudges)
                    const airAccel = (TANK_SPEED + state.bhopSpeed) * AIR_CONTROL * deltaTime * 2;
                    state.velocity.x += airMoveDir.x * airAccel;
                    state.velocity.z += airMoveDir.z * airAccel;
                }
            }

            // Process queued jump (works for both tap and hold)
            if (state.jumpQueued && state.onGround && !state.launchPending) {
                // Execute bhop jump
                state.velocity.y = BHOP_JUMP_FORCE;
                state.onGround = false;
                state.jumpQueued = false;

                // Check if this is a successful bhop (had horizontal momentum)
                const horizontalSpeed = Math.sqrt(state.velocity.x ** 2 + state.velocity.z ** 2);
                if (horizontalSpeed > 5) {
                    // Successful bhop - EXPONENTIAL speed boost!
                    state.bhopChain++;

                    // Exponential growth: multiply current speed + add base boost
                    state.bhopSpeed = (state.bhopSpeed + BHOP_SPEED_BOOST) * BHOP_MULTIPLIER;

                    // Exponential velocity boost in movement direction
                    const boostDir = new THREE.Vector3(state.velocity.x, 0, state.velocity.z).normalize();
                    const expBoost = BHOP_SPEED_BOOST * Math.pow(BHOP_MULTIPLIER, state.bhopChain);
                    state.velocity.x += boostDir.x * expBoost;
                    state.velocity.z += boostDir.z * expBoost;
                } else {
                    // Standing jump - reset chain
                    state.bhopChain = 0;
                }
            }

            // Queue jump if spacebar held while in air (for auto-bhop on landing)
            if (state.keys[' '] && !state.onGround) {
                state.jumpQueued = true;
            }

            // Check for glitch zones
            const currentZone = checkGlitchZones();
            if (currentZone && !state.launchPending) {
                state.isShaking = true;
                state.launchPending = true;
                state.launchTimer = 0;
            }

            // Handle launch timing
            if (state.launchPending) {
                state.launchTimer += deltaTime;
                if (state.launchTimer >= SHAKE_DURATION) {
                    launchTank();
                }
            }

            // Apply gravity when airborne
            if (!state.onGround) {
                state.velocity.y += GRAVITY * deltaTime;

                // Air rotation
                state.tank.rotation.x += state.angularVelocity * 0.3 * deltaTime;
                state.tank.rotation.z += state.angularVelocity * deltaTime;
            }

            // Apply velocity
            state.tank.position.add(state.velocity.clone().multiplyScalar(deltaTime));

            // Ground collision
            if (state.tank.position.y <= 0.1) {
                state.tank.position.y = 0.1;
                if (!state.onGround) {
                    // Landing impact
                    state.velocity.y = 0;
                    state.angularVelocity = 0;
                    // NO friction on landing - keep ALL momentum!
                }
                state.onGround = true;
            }

            // NO friction, NO decay - INFINITE SPEED!

            // Apply shaking effect
            applyShaking(deltaTime);

            // Reset key
            if (state.keys['r']) {
                resetTank();
            }

            // Pulse glitch zones
            state.glitchZones.forEach(zone => {
                zone.zone.userData.pulse += deltaTime * 3;
                zone.zone.material.opacity = 0.2 + Math.sin(zone.zone.userData.pulse) * 0.15;
            });

            // Camera follow with smooth lerp
            const targetCameraPos = state.tank.position.clone();
            const cameraDir = new THREE.Vector3(0, 0, 1).applyQuaternion(state.tank.quaternion);
            targetCameraPos.add(cameraDir.multiplyScalar(15));
            targetCameraPos.y = state.tank.position.y + 8;

            camera.position.lerp(targetCameraPos, 0.05);
            camera.lookAt(state.tank.position);

            // Update UI
            heightDisplay.textContent = Math.max(0, state.tank.position.y - 0.1).toFixed(1);
            const speed = Math.sqrt(state.velocity.x ** 2 + state.velocity.z ** 2) * 3.6;
            speedDisplay.textContent = speed.toFixed(1);
            bhopChainDisplay.textContent = state.bhopChain;

            // Color bhop chain based on count
            if (state.bhopChain >= 5) {
                bhopChainDisplay.style.color = '#e74c3c'; // Red for high chain
            } else if (state.bhopChain >= 3) {
                bhopChainDisplay.style.color = '#f39c12'; // Orange for medium
            } else if (state.bhopChain > 0) {
                bhopChainDisplay.style.color = '#4ecdc4'; // Cyan for active
            } else {
                bhopChainDisplay.style.color = '#fff';
            }

            if (!state.onGround) {
                if (state.bhopChain > 0) {
                    flyingStatusDisplay.innerHTML = `<span style="color: #4ecdc4;">BHOPPING! x${state.bhopChain}</span>`;
                } else {
                    flyingStatusDisplay.innerHTML = '<span class="flying">FLYING!</span>';
                }
            } else if (state.isShaking) {
                flyingStatusDisplay.innerHTML = '<span style="color: #f39c12;">GLITCH DETECTED!</span>';
            } else if (state.bhopChain > 0) {
                flyingStatusDisplay.innerHTML = `<span style="color: #4ecdc4;">BHOP CHAIN: ${state.bhopChain}</span>`;
            } else {
                flyingStatusDisplay.innerHTML = '';
            }

            // Update procedural world (infinite terrain)
            updateChunks(state.tank.position.x, state.tank.position.z);

            // Move ground and grid to follow player (seamless infinite ground)
            ground.position.x = state.tank.position.x;
            ground.position.z = state.tank.position.z;
            gridHelper.position.x = state.tank.position.x;
            gridHelper.position.z = state.tank.position.z;

            // Move sun light to follow player for consistent shadows
            sunLight.position.x = state.tank.position.x + 50;
            sunLight.position.z = state.tank.position.z + 50;
            sunLight.target.position.copy(state.tank.position);
            sunLight.target.updateMatrixWorld();

            renderer.render(scene, camera);
        }

        animate();

        console.log('Flying Tank Glitch loaded!');
        console.log('Drive into the RED zones to experience the flying glitch!');
        console.log('BHOP: Hold SPACE while moving to bunnyhop and gain speed!');
    </script>
</body>
</html>
